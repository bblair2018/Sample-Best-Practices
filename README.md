# Introduction 
This code was created while I was practicing for a technical interview for a company, that has since hired me. I have the following examples in this code:
- SOLID, contains the 5 principles of object oriented design.
- Class types --> Abstract, static, sealed, partial and inner. Also contians examples of using the ref and out keywords.
- 23 design patterns, which are defined below.

# Overview of Desing Patterns implemented in this project.

| # | Design Pattern       | Description                                                                                                           | Usefulness | Usefulness Reasoning                                                                                                  |
|---|----------------------|-----------------------------------------------------------------------------------------------------------------------|------------|-----------------------------------------------------------------------------------------------------------------------|
| 1 | Abstract Factory     | Provides an interface for creating families of related or dependent objects without specifying their concrete classes. | Useful     | Used to create a factory to generate objects with concrete methods and properties.                                 |
| 2 | Adapter              | Converts the interface of a class into another interface clients expect, enabling classes to work together that couldn't otherwise due to incompatible interfaces. | Useful     | Useful in integrating valid legacy code to new code.                                                                 |
| 3 | Bridge               | Ensures that only one instance of a class is created and provides a global point of access to it.                   | Useful     | Decouple classes from their various implementation modes.                                                            |
| 4 | Builder              | Separates the construction of an object from its representation, allowing the same construction process to create various representations. | Useful     | Used to build bits of an object one step at a time.                                                                  |
| 5 | Chain of Responsibility | Avoids coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. | Useful     | This design pattern allows for flexibility and dynamic handling of requests as the chain can be easily modified or extended without affecting the client code or the other classes in the chain. |
| 6 | Command              | Encapsulates a request as an object, allowing parameterization of clients with different requests, queue or log requests, and support undoable operations. | Useful     | Creates ways to set up and execute commands with redo/undo operations.                                                |
| 7 | Composite            | Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly. | Useful     | Creates a structure where objects and collections of the objects are treated in the same way. The structure can work with an individual object or a collection of them. |
| 8 | Decorator            | Adds new behaviors to an object dynamically by wrapping it with a decorator class.                                    | Useful     | Used to add new components to classes in an easy way.                                                                 |
| 9 | Fa√ßade               | Provides a simplified interface to a complex subsystem, hiding its complexities and making it easier to use.        | Useful     | Removes complexity from the class and makes it easy to use.                                                           |
|10 | Factory              | Defines an interface for creating objects but lets subclasses decide which class to instantiate.                     | Useful     | Can create new objects with different types of classes.                                                               |
|11 | Flyweight            | Reduces the memory usage of large numbers of similar objects by sharing common parts of the object's state.          | Useful     | Useful when using/creating many similar objects that share the same attributes, which saves memory. Those that share the same attributes point to the same instance of the object, saving memory. |
|12 | Interpreter          | Specifies how to evaluate sentences in a language, allowing the creation of a domain-specific language.              | Not-Useful | This can be used for translation from one language to another. I would not use this and do not find it useful to me.  |
|13 | Iterator             | Provides a way to access elements of an aggregate object sequentially without exposing its underlying representation.   | Not-Useful | I can use an array or list to iterate over a strongly-typed object. This is not useful to me.                          |
|14 | Mediator             | Defines an object that encapsulates how a set of objects interact, promoting loose coupling by keeping objects from referring to each other explicitly. | Useful     | Acts as a central point facilitating messages or operations to all of the other objects.                             |
|15 | Memento              | Provides the ability to restore an object to its previous state, capturing internal state without violating encapsulation. | Useful     | Used to save a snapshot of an object, in case it has to be restored.                                                  |
|16 | Observer             | Defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically. | Useful     | Specifies how something can be observed, and when it changes, all of the other objects are notified.                   |
|17 | Prototype            | Creates new objects by cloning existing ones, avoiding the need for complex initialization.                          | Useful     | Allows you to clone an object with defaults and then modify those settings if desired.                                |
|18 | Proxy                | Provides a surrogate or placeholder object that controls access to another object, allowing additional functionality to be provided when accessing the original object. | Useful     | Can create a wrapper for an object and then add additional functionality to the wrapper.                              |
|19 | Singleton            | Ensures that only one instance of a class is created and provides a global point of access to it.                     | Useful     | The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. |
|20 | State                | Allows an object to alter its behavior when its internal state changes, encapsulating the behavior within separate state classes. | Useful     | Allows an object to transition from one state to another or to set an object to a specific state.                     |
|21 | Strategy             | Defines a family of interchangeable algorithms, encapsulating each one and making them interchangeable within the same context. | Useful     | Allows for new strategies to be created and then run at runtime. New strategies can be implemented without modifying the existing code. |
|22 | Template             | Defines the skeleton of an algorithm in a base class, allowing subclasses to override certain steps of the algorithm without changing its structure. | Useful     | Creates a template for creating types of similar objects while creating specific steps for each of the similar objects. |
|23 | Visitor              | Separates an algorithm from an object structure, allowing new operations to be added to the object structure without modifying the objects themselves. | Useful     | Separates the algorithm (behavior) from the object structure, enabling the addition of new algorithms (visitors) without changing the existing classes. |
